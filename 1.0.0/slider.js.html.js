tui.util.defineNamespace("fedoc.content", {});
fedoc.content["slider.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Slider view\n * @author NHN Ent. FE Development Team &lt;dl_javascript@nhnent.com>\n */\n'use strict';\n\nvar util = global.tui.util;\nvar domutil = require('./core/domutil');\nvar domevent = require('./core/domevent');\nvar svgvml = require('./svgvml');\nvar colorutil = require('./colorutil');\nvar View = require('./core/view');\nvar Drag = require('./core/drag');\nvar tmpl = require('../template/slider');\n\n// Limitation position of point element inside of colorslider and hue bar\n// Minimum value can to be negative because that using color point of handle element is center point. not left, top point.\nvar COLORSLIDER_POS_LIMIT_RANGE = [-7, 112];\nvar HUEBAR_POS_LIMIT_RANGE = [-3, 115];\nvar HUE_WHEEL_MAX = 359.99;\n\n/**\n * @constructor\n * @extends {View}\n * @mixes CustomEvents\n * @param {object} options - options for view\n *  @param {string} options.cssPrefix - design css prefix\n * @param {HTMLElement} container - container element\n */\nfunction Slider(options, container) {\n    container = domutil.appendHTMLElement('div', container, options.cssPrefix + 'slider-container');\n    container.style.display = 'none';\n\n    View.call(this, options, container);\n\n    /**\n     * @type {object}\n     */\n    this.options = util.extend({\n        color: '#f8f8f8',\n        cssPrefix: 'tui-colorpicker-'\n    }, options);\n\n    /**\n     * Cache immutable data in click, drag events.\n     *\n     * (i.e. is event related with colorslider? or huebar?)\n     * @type {object}\n     * @property {boolean} isColorSlider\n     * @property {number[]} containerSize\n     */\n    this._dragDataCache = {};\n\n    /**\n     * Color slider handle element\n     * @type {SVG|VML}\n     */\n    this.sliderHandleElement = null;\n\n    /**\n     * hue bar handle element\n     * @type {SVG|VML}\n     */\n    this.huebarHandleElement = null;\n\n    /**\n     * Element that render base color in colorslider part\n     * @type {SVG|VML}\n     */\n    this.baseColorElement = null;\n\n    /**\n     * @type {Drag}\n     */\n    this.drag = new Drag({\n        distance: 0\n    }, container);\n    \n    // bind drag events\n    this.drag.on({\n        'dragStart': this._onDragStart,\n        'drag': this._onDrag,\n        'dragEnd': this._onDragEnd,\n        'click': this._onClick\n    }, this);\n}\n\nutil.inherit(Slider, View);\n\n/**\n * @override\n */\nSlider.prototype._beforeDestroy = function() {\n    this.drag.off();\n\n    this.drag = this.options = this._dragDataCache =\n        this.sliderHandleElement = this.huebarHandleElement =\n        this.baseColorElement = null;\n};\n\n/**\n * Toggle slider view\n * @param {boolean} onOff - set true then reveal slider view\n */\nSlider.prototype.toggle = function(onOff) {\n    this.container.style.display = !!onOff ? 'block' : 'none';\n};\n\n/**\n * Get slider display status\n * @returns {boolean} return true when slider is visible\n */\nSlider.prototype.isVisible = function() {\n    return this.container.style.display === 'block';\n};\n\n/**\n * Render slider view\n * @override\n * @param {string} colorStr - hex string color from parent view (Layout)\n */\nSlider.prototype.render = function(colorStr) {\n    var that = this,\n        container = that.container,\n        options = that.options,\n        html = tmpl.layout,\n        rgb,\n        hsv;\n\n    html = html.replace(/{{slider}}/, tmpl.slider);\n    html = html.replace(/{{huebar}}/, tmpl.huebar);\n    html = html.replace(/{{cssPrefix}}/g, options.cssPrefix);\n\n    that.container.innerHTML = html;\n\n    that.sliderHandleElement = domutil.find('.' + options.cssPrefix + 'slider-handle', container);\n    that.huebarHandleElement = domutil.find('.' + options.cssPrefix + 'huebar-handle', container);\n    that.baseColorElement = domutil.find('.' + options.cssPrefix + 'slider-basecolor', container);\n\n    rgb = colorutil.hexToRGB(colorStr);\n    hsv = colorutil.rgbToHSV.apply(null, rgb);\n\n    this.moveHue(hsv[0], true)\n    this.moveSaturationAndValue(hsv[1], hsv[2], true);\n};\n\n/**\n * Move colorslider by newLeft(X), newTop(Y) value\n * @private\n * @param {number} newLeft - left pixel value to move handle\n * @param {number} newTop - top pixel value to move handle\n * @param {boolean} [silent=false] - set true then not fire custom event\n */\nSlider.prototype._moveColorSliderHandle = function(newLeft, newTop, silent) {\n    var handle = this.sliderHandleElement,\n        handleColor;\n\n    // Check position limitation.\n    newTop = Math.max(COLORSLIDER_POS_LIMIT_RANGE[0], newTop);\n    newTop = Math.min(COLORSLIDER_POS_LIMIT_RANGE[1], newTop);\n    newLeft = Math.max(COLORSLIDER_POS_LIMIT_RANGE[0], newLeft);\n    newLeft = Math.min(COLORSLIDER_POS_LIMIT_RANGE[1], newLeft);\n\n    svgvml.setTranslateXY(handle, newLeft, newTop);\n\n    handleColor = newTop > 50 ? 'white' : 'black';\n    svgvml.setStrokeColor(handle, handleColor);\n\n    if (!silent) {\n        this.fire('_selectColor', {\n            color: colorutil.rgbToHEX.apply(null, this.getRGB())\n        });\n    }\n};\n\n/**\n * Move colorslider by supplied saturation and values.\n *\n * The movement of color slider handle follow HSV cylinder model. {@link https://en.wikipedia.org/wiki/HSL_and_HSV}\n * @param {number} saturation - the percent of saturation (0% ~ 100%)\n * @param {number} value - the percent of saturation (0% ~ 100%)\n * @param {boolean} [silent=false] - set true then not fire custom event\n */\nSlider.prototype.moveSaturationAndValue = function(saturation, value, silent) {\n    var absMin, maxValue,\n        newLeft, newTop;\n\n    saturation = saturation || 0;\n    value = value || 0;\n\n    absMin = Math.abs(COLORSLIDER_POS_LIMIT_RANGE[0]);\n    maxValue = COLORSLIDER_POS_LIMIT_RANGE[1];\n\n    // subtract absMin value because current color position is not left, top of handle element.\n    // The saturation. from left 0 to right 100\n    newLeft = ((saturation * maxValue) / 100) - absMin;\n    // The Value. from top 100 to bottom 0. that why newTop subtract by maxValue.\n    newTop = (maxValue - ((value * maxValue) / 100)) - absMin;\n\n    this._moveColorSliderHandle(newLeft, newTop, silent);\n};\n\n/**\n * Move color slider handle to supplied position\n *\n * The number of X, Y must be related value from color slider container\n * @private\n * @param {number} x - the pixel value to move handle \n * @param {number} y - the pixel value to move handle\n */\nSlider.prototype._moveColorSliderByPosition = function(x, y) {\n    var offset = COLORSLIDER_POS_LIMIT_RANGE[0];\n    this._moveColorSliderHandle(x + offset, y + offset);\n};\n\n/**\n * Get saturation and value value.\n * @returns {number[]} saturation and value\n */\nSlider.prototype.getSaturationAndValue = function() {\n    var absMin = Math.abs(COLORSLIDER_POS_LIMIT_RANGE[0]),\n        maxValue = absMin + COLORSLIDER_POS_LIMIT_RANGE[1],\n        position = svgvml.getTranslateXY(this.sliderHandleElement), \n        saturation, value;\n\n    saturation = ((position[1] + absMin) / maxValue) * 100;\n    // The value of HSV color model is inverted. top 100 ~ bottom 0. so subtract by 100\n    value = 100 - (((position[0] + absMin) / maxValue) * 100);\n\n    return [saturation, value];\n};\n\n/**\n * Move hue handle supplied pixel value\n * @private\n * @param {number} newTop - pixel to move hue handle\n * @param {boolean} [silent=false] - set true then not fire custom event\n */\nSlider.prototype._moveHueHandle = function(newTop, silent) {\n    var hueHandleElement = this.huebarHandleElement,\n        baseColorElement = this.baseColorElement,\n        newGradientColor,\n        hexStr;\n\n    newTop = Math.max(HUEBAR_POS_LIMIT_RANGE[0], newTop);\n    newTop = Math.min(HUEBAR_POS_LIMIT_RANGE[1], newTop);\n\n    svgvml.setTranslateY(hueHandleElement, newTop);\n\n    newGradientColor = colorutil.hsvToRGB(this.getHue(), 100, 100);\n    hexStr = colorutil.rgbToHEX.apply(null, newGradientColor);\n\n    svgvml.setGradientColorStop(baseColorElement, hexStr);\n\n    if (!silent) {\n        this.fire('_selectColor', {\n            color: colorutil.rgbToHEX.apply(null, this.getRGB()) \n        });\n    }\n};\n\n/**\n * Move hue bar handle by supplied degree\n * @param {number} degree - (0 ~ 359.9 degree)\n * @param {boolean} [silent=false] - set true then not fire custom event\n */\nSlider.prototype.moveHue = function(degree, silent) {\n    var newTop = 0,\n        absMin, maxValue;\n\n    absMin = Math.abs(HUEBAR_POS_LIMIT_RANGE[0]);\n    maxValue = absMin + HUEBAR_POS_LIMIT_RANGE[1];\n\n    degree = degree || 0;\n    newTop = ((maxValue * degree) / HUE_WHEEL_MAX) - absMin;\n\n    this._moveHueHandle(newTop, silent);\n};\n\n/**\n * Move hue bar handle by supplied percent\n * @private\n * @param {number} y - pixel value to move hue handle\n */\nSlider.prototype._moveHueByPosition = function(y) {\n    var offset = HUEBAR_POS_LIMIT_RANGE[0];\n\n    this._moveHueHandle(y + offset);\n};\n\n/**\n * Get huebar handle position by color degree\n * @returns {number} degree (0 ~ 359.9 degree)\n */\nSlider.prototype.getHue = function() {\n    var handle = this.huebarHandleElement,\n        position = svgvml.getTranslateXY(handle),\n        absMin, maxValue;\n\n    absMin = Math.abs(HUEBAR_POS_LIMIT_RANGE[0]);\n    maxValue = absMin + HUEBAR_POS_LIMIT_RANGE[1];\n\n    // maxValue : 359.99 = pos.y : x\n    return ((position[0] + absMin) * HUE_WHEEL_MAX) / maxValue;\n};\n\n/**\n * Get HSV value from slider\n * @returns {number[]} hsv values\n */\nSlider.prototype.getHSV = function() {\n    var sv = this.getSaturationAndValue(),\n        h = this.getHue();\n\n    return [h].concat(sv);\n};\n\n/**\n * Get RGB value from slider\n * @returns {number[]} RGB value\n */\nSlider.prototype.getRGB = function() {\n    return colorutil.hsvToRGB.apply(null, this.getHSV());\n};\n\n/**********\n * Drag event handler\n **********/\n\n/**\n * Cache immutable data when dragging or click view\n * @param {object} event - Click, DragStart event.\n * @returns {object} cached data.\n */\nSlider.prototype._prepareColorSliderForMouseEvent = function(event) {\n    var options = this.options,\n        sliderPart = domutil.closest(event.target, '.' + options.cssPrefix + 'slider-part'),\n        cache;\n\n    cache = this._dragDataCache = {\n        isColorSlider: domutil.hasClass(sliderPart, options.cssPrefix + 'slider-left'),\n        parentElement: sliderPart\n    };\n    \n    return cache;\n};\n\n/**\n * Click event handler\n * @param {object} clickEvent - Click event from Drag module\n */\nSlider.prototype._onClick = function(clickEvent) {\n    var cache = this._prepareColorSliderForMouseEvent(clickEvent),\n        mousePos = domevent.getMousePosition(clickEvent.originEvent, cache.parentElement);\n\n    if (cache.isColorSlider) {\n        this._moveColorSliderByPosition(mousePos[0], mousePos[1]);\n    } else {\n        this._moveHueByPosition(mousePos[1]);\n    }\n\n    this._dragDataCache = null;\n};\n\n/**\n * DragStart event handler\n * @param {object} dragStartEvent - dragStart event data from Drag#dragStart\n */\nSlider.prototype._onDragStart = function(dragStartEvent) {\n    this._prepareColorSliderForMouseEvent(dragStartEvent);\n};\n\n/**\n * Drag event handler\n * @param {Drag#drag} dragEvent - drag event data\n */\nSlider.prototype._onDrag = function(dragEvent) {\n    var cache = this._dragDataCache,\n        mousePos = domevent.getMousePosition(dragEvent.originEvent, cache.parentElement);\n\n    if (cache.isColorSlider) {\n        this._moveColorSliderByPosition(mousePos[0], mousePos[1]);\n    } else {\n        this._moveHueByPosition(mousePos[1]);\n    }\n};\n\n/**\n * Drag#dragEnd event handler\n */\nSlider.prototype._onDragEnd = function() {\n    this._dragDataCache = null;\n};\n\nutil.CustomEvents.mixin(Slider);\n\nmodule.exports = Slider;\n\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"